// Code generated by enumgen. DO NOT EDIT.

package testdata

import "fmt"

type E1 struct{ *string }

// Enum returns the name of the enumeration type for E1.
func (E1) Enum() string { return "E1" }

// String returns the string representation of E1 v.
func (v E1) String() string {
	if v.string == nil {
		return "<invalid>"
	}
	return *v.string
}

// Valid reports whether v is a valid E1 value.
func (v E1) Valid() bool { return v.string != nil }

var (
	_str_E1 = []string{"alpha", "bravo", "C"}

	A = E1{&_str_E1[0]}
	B = E1{&_str_E1[1]}
	C = E1{&_str_E1[2]}
)

type E2 struct{ *string }

// Enum returns the name of the enumeration type for E2.
func (E2) Enum() string { return "E2" }

// String returns the string representation of E2 v.
func (v E2) String() string {
	if v.string == nil {
		return "<invalid>"
	}
	return *v.string
}

// Valid reports whether v is a valid E2 value.
func (v E2) Valid() bool { return v.string != nil }

var (
	_str_E2 = []string{"A", "B"}

	E2_Invalid = E2{}
	E2_A       = E2{&_str_E2[0]}
	E2_B       = E2{&_str_E2[1]}
)

type E3 struct{ *string }

// Enum returns the name of the enumeration type for E3.
func (E3) Enum() string { return "E3" }

// String returns the string representation of E3 v.
func (v E3) String() string {
	if v.string == nil {
		return "<invalid>"
	}
	return *v.string
}

// Valid reports whether v is a valid E3 value.
func (v E3) Valid() bool { return v.string != nil }

// Set implements part of the flag.Value interface for E3.
// A value must equal the string representation of an enumerator.
func (v *E3) Set(s string) error {
	for i, opt := range _str_E3 {
		if opt == s {
			v.string = &_str_E3[i]
			return nil
		}
	}
	return fmt.Errorf("invalid value for E3: %q", s)
}

// MarshalText encodes the value of the E3 enumerator as text.
// It satisfies the encoding.TextMarshaler interface.
func (v E3) MarshalText() ([]byte, error) { return []byte(v.String()), nil }

// UnarshalText decodes the value of the E3 enumerator from a string.
// It reports an error if data does not encode a known enumerator.
// An empty slice decodes to the invalid (zero) value.
// This method satisfies the encoding.TextUnmarshaler interface.
func (v *E3) UnmarshalText(data []byte) error {
	text := string(data)
	if text == "" || text == (E3{}).String() {
		v.string = nil
		return nil
	}
	for i, opt := range _str_E3 {
		if opt == text {
			v.string = &_str_E3[i]
			return nil
		}
	}
	return fmt.Errorf("invalid value for E3: %q", text)
}

var (
	_str_E3 = []string{"foo", "bar"}

	X = E3{&_str_E3[0]}
	Y = E3{&_str_E3[1]}
)

// GeneratorHash is used by the tests to verify that the testdata
// package is updated when the code generator changes.
const GeneratorHash = "8aa3ffe76f542c5d97c19060e8a6a0aa3b1f11cde149d8ec3174f77b5ce8cf1e"
